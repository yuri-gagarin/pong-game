'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCompilerHostFromProjectRoot = exports.createCompilerHostFromConfigFile = exports.createCompilerHostFromBabelRc = undefined;

/**
 * Creates a compiler host from a .babelrc file. This method is usually called
 * from {@link createCompilerHostFromProjectRoot} instead of used directly.
 *
 * @param  {string} file  The path to a .babelrc file
 *
 * @param  {string} rootCacheDir (optional)  The directory to use as a cache.
 *
 * @return {Promise<CompilerHost>}  A set-up compiler host
 */
let createCompilerHostFromBabelRc = exports.createCompilerHostFromBabelRc = (() => {
  var _ref = _asyncToGenerator(function* (file) {
    let rootCacheDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    let info = JSON.parse((yield _promise.pfs.readFile(file, 'utf8')));

    // package.json
    if ('babel' in info) {
      info = info.babel;
    }

    if ('env' in info) {
      let ourEnv = process.env.BABEL_ENV || process.env.NODE_ENV || 'development';
      info = info.env[ourEnv];
    }

    // Are we still package.json (i.e. is there no babel info whatsoever?)
    if ('name' in info && 'version' in info) {
      let appRoot = _path2.default.dirname(file);
      return createCompilerHostFromConfiguration({
        appRoot: appRoot,
        options: getDefaultConfiguration(appRoot),
        rootCacheDir,
        sourceMapPath
      });
    }

    return createCompilerHostFromConfiguration({
      appRoot: _path2.default.dirname(file),
      options: {
        'application/javascript': info
      },
      rootCacheDir,
      sourceMapPath
    });
  });

  return function createCompilerHostFromBabelRc(_x5) {
    return _ref.apply(this, arguments);
  };
})();

/**
 * Creates a compiler host from a .compilerc file. This method is usually called
 * from {@link createCompilerHostFromProjectRoot} instead of used directly.
 *
 * @param  {string} file  The path to a .compilerc file
 *
 * @param  {string} rootCacheDir (optional)  The directory to use as a cache.
 *
 * @return {Promise<CompilerHost>}  A set-up compiler host
 */


let createCompilerHostFromConfigFile = exports.createCompilerHostFromConfigFile = (() => {
  var _ref2 = _asyncToGenerator(function* (file) {
    let rootCacheDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    let info = JSON.parse((yield _promise.pfs.readFile(file, 'utf8')));

    if ('env' in info) {
      let ourEnv = process.env.ELECTRON_COMPILE_ENV || process.env.NODE_ENV || 'development';
      info = info.env[ourEnv];
    }

    return createCompilerHostFromConfiguration({
      appRoot: _path2.default.dirname(file),
      options: info,
      rootCacheDir,
      sourceMapPath
    });
  });

  return function createCompilerHostFromConfigFile(_x8) {
    return _ref2.apply(this, arguments);
  };
})();

/**
 * Creates a configured {@link CompilerHost} instance from the project root
 * directory. This method first searches for a .compilerc (or .compilerc.json), then falls back to the
 * default locations for Babel configuration info. If neither are found, defaults
 * to standard settings
 *
 * @param  {string} rootDir  The root application directory (i.e. the directory
 *                           that has the app's package.json)
 *
 * @param  {string} rootCacheDir (optional)  The directory to use as a cache.
 *
 * @param {string} sourceMapPath (optional) The directory to store sourcemap separately
 *                               if compiler option enabled to emit.
 *
 * @return {Promise<CompilerHost>}  A set-up compiler host
 */


let createCompilerHostFromProjectRoot = exports.createCompilerHostFromProjectRoot = (() => {
  var _ref3 = _asyncToGenerator(function* (rootDir) {
    let rootCacheDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    let compilerc = _path2.default.join(rootDir, '.compilerc');
    if (statSyncNoException(compilerc)) {
      d(`Found a .compilerc at ${compilerc}, using it`);
      return yield createCompilerHostFromConfigFile(compilerc, rootCacheDir, sourceMapPath);
    }
    compilerc += '.json';
    if (statSyncNoException(compilerc)) {
      d(`Found a .compilerc at ${compilerc}, using it`);
      return yield createCompilerHostFromConfigFile(compilerc, rootCacheDir, sourceMapPath);
    }

    let babelrc = _path2.default.join(rootDir, '.babelrc');
    if (statSyncNoException(babelrc)) {
      d(`Found a .babelrc at ${babelrc}, using it`);
      return yield createCompilerHostFromBabelRc(babelrc, rootCacheDir, sourceMapPath);
    }

    d(`Using package.json or default parameters at ${rootDir}`);
    return yield createCompilerHostFromBabelRc(_path2.default.join(rootDir, 'package.json'), rootCacheDir, sourceMapPath);
  });

  return function createCompilerHostFromProjectRoot(_x11) {
    return _ref3.apply(this, arguments);
  };
})();

exports.initializeGlobalHooks = initializeGlobalHooks;
exports.init = init;
exports.createCompilerHostFromConfiguration = createCompilerHostFromConfiguration;
exports.createCompilerHostFromBabelRcSync = createCompilerHostFromBabelRcSync;
exports.createCompilerHostFromConfigFileSync = createCompilerHostFromConfigFileSync;
exports.createCompilerHostFromProjectRootSync = createCompilerHostFromProjectRootSync;
exports.calculateDefaultCompileCacheDirectory = calculateDefaultCompileCacheDirectory;
exports.getDefaultConfiguration = getDefaultConfiguration;
exports.createCompilers = createCompilers;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _zlib = require('zlib');

var _zlib2 = _interopRequireDefault(_zlib);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _promise = require('./promise');

var _fileChangeCache = require('./file-change-cache');

var _fileChangeCache2 = _interopRequireDefault(_fileChangeCache);

var _compilerHost = require('./compiler-host');

var _compilerHost2 = _interopRequireDefault(_compilerHost);

var _requireHook = require('./require-hook');

var _requireHook2 = _interopRequireDefault(_requireHook);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const d = require('debug')('electron-compile:config-parser');

// NB: We intentionally delay-load this so that in production, you can create
// cache-only versions of these compilers
let allCompilerClasses = null;

function statSyncNoException(fsPath) {
  if ('statSyncNoException' in _fs2.default) {
    return _fs2.default.statSyncNoException(fsPath);
  }

  try {
    return _fs2.default.statSync(fsPath);
  } catch (e) {
    return null;
  }
}

/**
 * Initialize the global hooks (protocol hook for file:, node.js hook)
 * independent of initializing the compiler. This method is usually called by
 * init instead of directly
 *
 * @param {CompilerHost} compilerHost  The compiler host to use.
 *
 */
function initializeGlobalHooks(compilerHost) {
  let isProduction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  let globalVar = global || window;
  globalVar.globalCompilerHost = compilerHost;

  (0, _requireHook2.default)(compilerHost, isProduction);

  if ('type' in process && process.type === 'browser') {
    var _require = require('electron');

    const app = _require.app;

    var _require2 = require('./protocol-hook');

    const initializeProtocolHook = _require2.initializeProtocolHook;


    let protoify = function () {
      initializeProtocolHook(compilerHost);
    };
    if (app.isReady()) {
      protoify();
    } else {
      app.on('ready', protoify);
    }
  }
}

/**
 * Initialize electron-compile and set it up, either for development or
 * production use. This is almost always the only method you need to use in order
 * to use electron-compile.
 *
 * @param  {string} appRoot  The top-level directory for your application (i.e.
 *                           the one which has your package.json).
 *
 * @param  {string} mainModule  The module to require in, relative to the module
 *                              calling init, that will start your app. Write this
 *                              as if you were writing a require call from here.
 *
 * @param  {bool} productionMode   If explicitly True/False, will set read-only
 *                                 mode to be disabled/enabled. If not, we'll
 *                                 guess based on the presence of a production
 *                                 cache.
 *
 * @param  {string} cacheDir  If not passed in, read-only will look in
 *                            `appRoot/.cache` and dev mode will compile to a
 *                            temporary directory. If it is passed in, both modes
 *                            will cache to/from `appRoot/{cacheDir}`
 *
 * @param {string} sourceMapPath (optional) The directory to store sourcemap separately
 *                               if compiler option enabled to emit.
 *                               Default to cachePath if not specified, will be ignored for read-only mode.
 */
function init(appRoot, mainModule) {
  let productionMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  let cacheDir = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  let sourceMapPath = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

  let compilerHost = null;
  let rootCacheDir = _path2.default.join(appRoot, cacheDir || '.cache');

  if (productionMode === null) {
    productionMode = !!statSyncNoException(rootCacheDir);
  }

  if (productionMode) {
    compilerHost = _compilerHost2.default.createReadonlyFromConfigurationSync(rootCacheDir, appRoot);
  } else {
    // if cacheDir was passed in, pass it along. Otherwise, default to a tempdir.
    const cachePath = cacheDir ? rootCacheDir : null;
    const mapPath = sourceMapPath ? _path2.default.join(appRoot, sourceMapPath) : cachePath;
    compilerHost = createCompilerHostFromProjectRootSync(appRoot, cachePath, mapPath);
  }

  initializeGlobalHooks(compilerHost, productionMode);
  require.main.require(mainModule);
}

/**
 * Creates a {@link CompilerHost} with the given information. This method is
 * usually called by {@link createCompilerHostFromProjectRoot}.
 *
 * @private
 */
function createCompilerHostFromConfiguration(info) {
  let compilers = createCompilers();
  let rootCacheDir = info.rootCacheDir || calculateDefaultCompileCacheDirectory();
  const sourceMapPath = info.sourceMapPath || info.rootCacheDir;

  if (info.sourceMapPath) {
    createSourceMapDirectory(sourceMapPath);
  }

  d(`Creating CompilerHost: ${JSON.stringify(info)}, rootCacheDir = ${rootCacheDir}, sourceMapPath = ${sourceMapPath}`);
  let fileChangeCache = new _fileChangeCache2.default(info.appRoot);

  let compilerInfo = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
  let json = {};
  if (_fs2.default.existsSync(compilerInfo)) {
    let buf = _fs2.default.readFileSync(compilerInfo);
    json = JSON.parse(_zlib2.default.gunzipSync(buf));
    fileChangeCache = _fileChangeCache2.default.loadFromData(json.fileChangeCache, info.appRoot, false);
  }

  Object.keys(info.options || {}).forEach(x => {
    let opts = info.options[x];
    if (!(x in compilers)) {
      throw new Error(`Found compiler settings for missing compiler: ${x}`);
    }

    // NB: Let's hope this isn't a valid compiler option...
    if (opts.passthrough) {
      compilers[x] = compilers['text/plain'];
      delete opts.passthrough;
    }

    d(`Setting options for ${x}: ${JSON.stringify(opts)}`);
    compilers[x].compilerOptions = opts;
  });

  let ret = new _compilerHost2.default(rootCacheDir, compilers, fileChangeCache, false, compilers['text/plain'], null, json.mimeTypesToRegister);

  // NB: It's super important that we guarantee that the configuration is saved
  // out, because we'll need to re-read it in the renderer process
  d(`Created compiler host with options: ${JSON.stringify(info)}`);
  ret.saveConfigurationSync();
  return ret;
}function createCompilerHostFromBabelRcSync(file) {
  let rootCacheDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  let info = JSON.parse(_fs2.default.readFileSync(file, 'utf8'));

  // package.json
  if ('babel' in info) {
    info = info.babel;
  }

  if ('env' in info) {
    let ourEnv = process.env.BABEL_ENV || process.env.NODE_ENV || 'development';
    info = info.env[ourEnv];
  }

  // Are we still package.json (i.e. is there no babel info whatsoever?)
  if ('name' in info && 'version' in info) {
    let appRoot = _path2.default.dirname(file);
    return createCompilerHostFromConfiguration({
      appRoot: appRoot,
      options: getDefaultConfiguration(appRoot),
      rootCacheDir,
      sourceMapPath
    });
  }

  return createCompilerHostFromConfiguration({
    appRoot: _path2.default.dirname(file),
    options: {
      'application/javascript': info
    },
    rootCacheDir,
    sourceMapPath
  });
}

function createCompilerHostFromConfigFileSync(file) {
  let rootCacheDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  let info = JSON.parse(_fs2.default.readFileSync(file, 'utf8'));

  if ('env' in info) {
    let ourEnv = process.env.ELECTRON_COMPILE_ENV || process.env.NODE_ENV || 'development';
    info = info.env[ourEnv];
  }

  return createCompilerHostFromConfiguration({
    appRoot: _path2.default.dirname(file),
    options: info,
    rootCacheDir,
    sourceMapPath
  });
}

function createCompilerHostFromProjectRootSync(rootDir) {
  let rootCacheDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  let compilerc = _path2.default.join(rootDir, '.compilerc');
  if (statSyncNoException(compilerc)) {
    d(`Found a .compilerc at ${compilerc}, using it`);
    return createCompilerHostFromConfigFileSync(compilerc, rootCacheDir, sourceMapPath);
  }

  let babelrc = _path2.default.join(rootDir, '.babelrc');
  if (statSyncNoException(babelrc)) {
    d(`Found a .babelrc at ${babelrc}, using it`);
    return createCompilerHostFromBabelRcSync(babelrc, rootCacheDir, sourceMapPath);
  }

  d(`Using package.json or default parameters at ${rootDir}`);
  return createCompilerHostFromBabelRcSync(_path2.default.join(rootDir, 'package.json'), rootCacheDir, sourceMapPath);
}

/**
 * Returns what electron-compile would use as a default rootCacheDir. Usually only
 * used for debugging purposes
 *
 * @return {string}  A path that may or may not exist where electron-compile would
 *                   set up a development mode cache.
 */
function calculateDefaultCompileCacheDirectory() {
  let tmpDir = process.env.TEMP || process.env.TMPDIR || '/tmp';
  let hash = require('crypto').createHash('md5').update(process.execPath).digest('hex');

  let cacheDir = _path2.default.join(tmpDir, `compileCache_${hash}`);
  _mkdirp2.default.sync(cacheDir);

  d(`Using default cache directory: ${cacheDir}`);
  return cacheDir;
}

function createSourceMapDirectory(sourceMapPath) {
  _mkdirp2.default.sync(sourceMapPath);
  d(`Using separate sourcemap path at ${sourceMapPath}`);
}

function versionToFloat(ver) {
  return parseFloat(ver.replace(/^([^\.]\.[^\.])\..*$/, '$1'));
}

function getElectronVersion(rootDir) {
  if (process.versions.electron) {
    return versionToFloat(process.versions.electron);
  }

  let ourPkgJson = require(_path2.default.join(rootDir, 'package.json'));

  let version = ['electron-prebuilt-compile', 'electron'].map(mod => {
    if (ourPkgJson.devDependencies && ourPkgJson.devDependencies[mod]) {
      // NB: lol this code
      let verRange = ourPkgJson.devDependencies[mod];
      let m = verRange.match(/(\d+\.\d+\.\d+)/);
      if (m && m[1]) return m[1];
    }

    try {
      return process.mainModule.require(`${mod}/package.json`).version;
    } catch (e) {
      // NB: This usually doesn't work, but sometimes maybe?
    }

    try {
      let p = _path2.default.join(rootDir, mod, 'package.json');
      return require(p).version;
    } catch (e) {
      return null;
    }
  }).find(x => !!x);

  if (!version) {
    throw new Error("Can't automatically discover the version of Electron, you probably need a .compilerc file");
  }

  return versionToFloat(version);
}

/**
 * Returns the default .configrc if no configuration information can be found.
 *
 * @return {Object}  A list of default config settings for electron-compiler.
 */
function getDefaultConfiguration(rootDir) {
  return {
    'application/javascript': {
      "presets": [["env", {
        "targets": {
          "electron": getElectronVersion(rootDir)
        }
      }], "react"],
      "sourceMaps": "inline"
    }
  };
}

/**
 * Allows you to create new instances of all compilers that are supported by
 * electron-compile and use them directly. Currently supports Babel, CoffeeScript,
 * TypeScript, Less, and Jade.
 *
 * @return {Object}  An Object whose Keys are MIME types, and whose values
 * are instances of @{link CompilerBase}.
 */
function createCompilers() {
  if (!allCompilerClasses) {
    // First we want to see if electron-compilers itself has been installed with
    // devDependencies. If that's not the case, check to see if
    // electron-compilers is installed as a peer dependency (probably as a
    // devDependency of the root project).
    const locations = ['electron-compilers', '../../electron-compilers'];

    for (let location of locations) {
      try {
        allCompilerClasses = require(location);
      } catch (e) {
        // Yolo
      }
    }

    if (!allCompilerClasses) {
      throw new Error("Electron compilers not found but were requested to be loaded");
    }
  }

  // NB: Note that this code is carefully set up so that InlineHtmlCompiler
  // (i.e. classes with `createFromCompilers`) initially get an empty object,
  // but will have a reference to the final result of what we return, which
  // resolves the circular dependency we'd otherwise have here.
  let ret = {};
  let instantiatedClasses = allCompilerClasses.map(Klass => {
    if ('createFromCompilers' in Klass) {
      return Klass.createFromCompilers(ret);
    } else {
      return new Klass();
    }
  });

  instantiatedClasses.reduce((acc, x) => {
    let Klass = Object.getPrototypeOf(x).constructor;

    for (let type of Klass.getInputMimeTypes()) {
      acc[type] = x;
    }
    return acc;
  }, ret);

  return ret;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb25maWctcGFyc2VyLmpzIl0sIm5hbWVzIjpbImZpbGUiLCJyb290Q2FjaGVEaXIiLCJzb3VyY2VNYXBQYXRoIiwiaW5mbyIsIkpTT04iLCJwYXJzZSIsInJlYWRGaWxlIiwiYmFiZWwiLCJvdXJFbnYiLCJwcm9jZXNzIiwiZW52IiwiQkFCRUxfRU5WIiwiTk9ERV9FTlYiLCJhcHBSb290IiwiZGlybmFtZSIsImNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWd1cmF0aW9uIiwib3B0aW9ucyIsImdldERlZmF1bHRDb25maWd1cmF0aW9uIiwiY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUJhYmVsUmMiLCJFTEVDVFJPTl9DT01QSUxFX0VOViIsImNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWdGaWxlIiwicm9vdERpciIsImNvbXBpbGVyYyIsImpvaW4iLCJzdGF0U3luY05vRXhjZXB0aW9uIiwiZCIsImJhYmVscmMiLCJjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3QiLCJpbml0aWFsaXplR2xvYmFsSG9va3MiLCJpbml0IiwiY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUJhYmVsUmNTeW5jIiwiY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ0ZpbGVTeW5jIiwiY3JlYXRlQ29tcGlsZXJIb3N0RnJvbVByb2plY3RSb290U3luYyIsImNhbGN1bGF0ZURlZmF1bHRDb21waWxlQ2FjaGVEaXJlY3RvcnkiLCJjcmVhdGVDb21waWxlcnMiLCJyZXF1aXJlIiwiYWxsQ29tcGlsZXJDbGFzc2VzIiwiZnNQYXRoIiwic3RhdFN5bmMiLCJlIiwiY29tcGlsZXJIb3N0IiwiaXNQcm9kdWN0aW9uIiwiZ2xvYmFsVmFyIiwiZ2xvYmFsIiwid2luZG93IiwiZ2xvYmFsQ29tcGlsZXJIb3N0IiwidHlwZSIsImFwcCIsImluaXRpYWxpemVQcm90b2NvbEhvb2siLCJwcm90b2lmeSIsImlzUmVhZHkiLCJvbiIsIm1haW5Nb2R1bGUiLCJwcm9kdWN0aW9uTW9kZSIsImNhY2hlRGlyIiwiY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvblN5bmMiLCJjYWNoZVBhdGgiLCJtYXBQYXRoIiwibWFpbiIsImNvbXBpbGVycyIsImNyZWF0ZVNvdXJjZU1hcERpcmVjdG9yeSIsInN0cmluZ2lmeSIsImZpbGVDaGFuZ2VDYWNoZSIsImNvbXBpbGVySW5mbyIsImpzb24iLCJleGlzdHNTeW5jIiwiYnVmIiwicmVhZEZpbGVTeW5jIiwiZ3VuemlwU3luYyIsImxvYWRGcm9tRGF0YSIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwieCIsIm9wdHMiLCJFcnJvciIsInBhc3N0aHJvdWdoIiwiY29tcGlsZXJPcHRpb25zIiwicmV0IiwibWltZVR5cGVzVG9SZWdpc3RlciIsInNhdmVDb25maWd1cmF0aW9uU3luYyIsInRtcERpciIsIlRFTVAiLCJUTVBESVIiLCJoYXNoIiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsImV4ZWNQYXRoIiwiZGlnZXN0Iiwic3luYyIsInZlcnNpb25Ub0Zsb2F0IiwidmVyIiwicGFyc2VGbG9hdCIsInJlcGxhY2UiLCJnZXRFbGVjdHJvblZlcnNpb24iLCJ2ZXJzaW9ucyIsImVsZWN0cm9uIiwib3VyUGtnSnNvbiIsInZlcnNpb24iLCJtYXAiLCJtb2QiLCJkZXZEZXBlbmRlbmNpZXMiLCJ2ZXJSYW5nZSIsIm0iLCJtYXRjaCIsInAiLCJmaW5kIiwibG9jYXRpb25zIiwibG9jYXRpb24iLCJpbnN0YW50aWF0ZWRDbGFzc2VzIiwiS2xhc3MiLCJjcmVhdGVGcm9tQ29tcGlsZXJzIiwicmVkdWNlIiwiYWNjIiwiZ2V0UHJvdG90eXBlT2YiLCJjb25zdHJ1Y3RvciIsImdldElucHV0TWltZVR5cGVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBNEpBOzs7Ozs7Ozs7OzsrQkFVTyxXQUE2Q0EsSUFBN0MsRUFBNEY7QUFBQSxRQUF6Q0MsWUFBeUMsdUVBQTVCLElBQTRCO0FBQUEsUUFBdEJDLGFBQXNCLHVFQUFOLElBQU07O0FBQ2pHLFFBQUlDLE9B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Q0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJRyxNQUFNLEVBQVY7QUFDQSxNQUFJK0Isc0JBQXNCekUsbUJBQW1CK0QsR0FBbkIsQ0FBd0JXLEtBQUQsSUFBVztBQUMxRCxRQUFJLHlCQUF5QkEsS0FBN0IsRUFBb0M7QUFDbEMsYUFBT0EsTUFBTUMsbUJBQU4sQ0FBMEJqQyxHQUExQixDQUFQO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsYUFBTyxJQUFJZ0MsS0FBSixFQUFQO0FBQ0Q7QUFDRixHQU55QixDQUExQjs7QUFRQUQsc0JBQW9CRyxNQUFwQixDQUEyQixDQUFDQyxHQUFELEVBQUt4QyxDQUFMLEtBQVc7QUFDcEMsUUFBSXFDLFFBQVF4QyxPQUFPNEMsY0FBUCxDQUFzQnpDLENBQXRCLEVBQXlCMEMsV0FBckM7O0FBRUEsU0FBSyxJQUFJckUsSUFBVCxJQUFpQmdFLE1BQU1NLGlCQUFOLEVBQWpCLEVBQTRDO0FBQUVILFVBQUluRSxJQUFKLElBQVkyQixDQUFaO0FBQWdCO0FBQzlELFdBQU93QyxHQUFQO0FBQ0QsR0FMRCxFQUtHbkMsR0FMSDs7QUFPQSxTQUFPQSxHQUFQO0FBQ0QiLCJmaWxlIjoiY29uZmlnLXBhcnNlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xyXG5pbXBvcnQgemxpYiBmcm9tICd6bGliJztcclxuaW1wb3J0IG1rZGlycCBmcm9tICdta2RpcnAnO1xyXG5pbXBvcnQge3Bmc30gZnJvbSAnLi9wcm9taXNlJztcclxuXHJcbmltcG9ydCBGaWxlQ2hhbmdlZENhY2hlIGZyb20gJy4vZmlsZS1jaGFuZ2UtY2FjaGUnO1xyXG5pbXBvcnQgQ29tcGlsZXJIb3N0IGZyb20gJy4vY29tcGlsZXItaG9zdCc7XHJcbmltcG9ydCByZWdpc3RlclJlcXVpcmVFeHRlbnNpb24gZnJvbSAnLi9yZXF1aXJlLWhvb2snO1xyXG5cclxuY29uc3QgZCA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VsZWN0cm9uLWNvbXBpbGU6Y29uZmlnLXBhcnNlcicpO1xyXG5cclxuLy8gTkI6IFdlIGludGVudGlvbmFsbHkgZGVsYXktbG9hZCB0aGlzIHNvIHRoYXQgaW4gcHJvZHVjdGlvbiwgeW91IGNhbiBjcmVhdGVcclxuLy8gY2FjaGUtb25seSB2ZXJzaW9ucyBvZiB0aGVzZSBjb21waWxlcnNcclxubGV0IGFsbENvbXBpbGVyQ2xhc3NlcyA9IG51bGw7XHJcblxyXG5mdW5jdGlvbiBzdGF0U3luY05vRXhjZXB0aW9uKGZzUGF0aCkge1xyXG4gIGlmICgnc3RhdFN5bmNOb0V4Y2VwdGlvbicgaW4gZnMpIHtcclxuICAgIHJldHVybiBmcy5zdGF0U3luY05vRXhjZXB0aW9uKGZzUGF0aCk7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGZzLnN0YXRTeW5jKGZzUGF0aCk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgdGhlIGdsb2JhbCBob29rcyAocHJvdG9jb2wgaG9vayBmb3IgZmlsZTosIG5vZGUuanMgaG9vaylcclxuICogaW5kZXBlbmRlbnQgb2YgaW5pdGlhbGl6aW5nIHRoZSBjb21waWxlci4gVGhpcyBtZXRob2QgaXMgdXN1YWxseSBjYWxsZWQgYnlcclxuICogaW5pdCBpbnN0ZWFkIG9mIGRpcmVjdGx5XHJcbiAqXHJcbiAqIEBwYXJhbSB7Q29tcGlsZXJIb3N0fSBjb21waWxlckhvc3QgIFRoZSBjb21waWxlciBob3N0IHRvIHVzZS5cclxuICpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplR2xvYmFsSG9va3MoY29tcGlsZXJIb3N0LCBpc1Byb2R1Y3Rpb249ZmFsc2UpIHtcclxuICBsZXQgZ2xvYmFsVmFyID0gKGdsb2JhbCB8fCB3aW5kb3cpO1xyXG4gIGdsb2JhbFZhci5nbG9iYWxDb21waWxlckhvc3QgPSBjb21waWxlckhvc3Q7XHJcblxyXG4gIHJlZ2lzdGVyUmVxdWlyZUV4dGVuc2lvbihjb21waWxlckhvc3QsIGlzUHJvZHVjdGlvbik7XHJcblxyXG4gIGlmICgndHlwZScgaW4gcHJvY2VzcyAmJiBwcm9jZXNzLnR5cGUgPT09ICdicm93c2VyJykge1xyXG4gICAgY29uc3QgeyBhcHAgfSA9IHJlcXVpcmUoJ2VsZWN0cm9uJyk7XHJcbiAgICBjb25zdCB7IGluaXRpYWxpemVQcm90b2NvbEhvb2sgfSA9IHJlcXVpcmUoJy4vcHJvdG9jb2wtaG9vaycpO1xyXG5cclxuICAgIGxldCBwcm90b2lmeSA9IGZ1bmN0aW9uKCkgeyBpbml0aWFsaXplUHJvdG9jb2xIb29rKGNvbXBpbGVySG9zdCk7IH07XHJcbiAgICBpZiAoYXBwLmlzUmVhZHkoKSkge1xyXG4gICAgICBwcm90b2lmeSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYXBwLm9uKCdyZWFkeScsIHByb3RvaWZ5KTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBlbGVjdHJvbi1jb21waWxlIGFuZCBzZXQgaXQgdXAsIGVpdGhlciBmb3IgZGV2ZWxvcG1lbnQgb3JcclxuICogcHJvZHVjdGlvbiB1c2UuIFRoaXMgaXMgYWxtb3N0IGFsd2F5cyB0aGUgb25seSBtZXRob2QgeW91IG5lZWQgdG8gdXNlIGluIG9yZGVyXHJcbiAqIHRvIHVzZSBlbGVjdHJvbi1jb21waWxlLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGFwcFJvb3QgIFRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IGZvciB5b3VyIGFwcGxpY2F0aW9uIChpLmUuXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9uZSB3aGljaCBoYXMgeW91ciBwYWNrYWdlLmpzb24pLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG1haW5Nb2R1bGUgIFRoZSBtb2R1bGUgdG8gcmVxdWlyZSBpbiwgcmVsYXRpdmUgdG8gdGhlIG1vZHVsZVxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxpbmcgaW5pdCwgdGhhdCB3aWxsIHN0YXJ0IHlvdXIgYXBwLiBXcml0ZSB0aGlzXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXMgaWYgeW91IHdlcmUgd3JpdGluZyBhIHJlcXVpcmUgY2FsbCBmcm9tIGhlcmUuXHJcbiAqXHJcbiAqIEBwYXJhbSAge2Jvb2x9IHByb2R1Y3Rpb25Nb2RlICAgSWYgZXhwbGljaXRseSBUcnVlL0ZhbHNlLCB3aWxsIHNldCByZWFkLW9ubHlcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlIHRvIGJlIGRpc2FibGVkL2VuYWJsZWQuIElmIG5vdCwgd2UnbGxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBndWVzcyBiYXNlZCBvbiB0aGUgcHJlc2VuY2Ugb2YgYSBwcm9kdWN0aW9uXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gY2FjaGVEaXIgIElmIG5vdCBwYXNzZWQgaW4sIHJlYWQtb25seSB3aWxsIGxvb2sgaW5cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYGFwcFJvb3QvLmNhY2hlYCBhbmQgZGV2IG1vZGUgd2lsbCBjb21waWxlIHRvIGFcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcG9yYXJ5IGRpcmVjdG9yeS4gSWYgaXQgaXMgcGFzc2VkIGluLCBib3RoIG1vZGVzXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgY2FjaGUgdG8vZnJvbSBgYXBwUm9vdC97Y2FjaGVEaXJ9YFxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlTWFwUGF0aCAob3B0aW9uYWwpIFRoZSBkaXJlY3RvcnkgdG8gc3RvcmUgc291cmNlbWFwIHNlcGFyYXRlbHlcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgY29tcGlsZXIgb3B0aW9uIGVuYWJsZWQgdG8gZW1pdC5cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB0byBjYWNoZVBhdGggaWYgbm90IHNwZWNpZmllZCwgd2lsbCBiZSBpZ25vcmVkIGZvciByZWFkLW9ubHkgbW9kZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpbml0KGFwcFJvb3QsIG1haW5Nb2R1bGUsIHByb2R1Y3Rpb25Nb2RlID0gbnVsbCwgY2FjaGVEaXIgPSBudWxsLCBzb3VyY2VNYXBQYXRoID0gbnVsbCkge1xyXG4gIGxldCBjb21waWxlckhvc3QgPSBudWxsO1xyXG4gIGxldCByb290Q2FjaGVEaXIgPSBwYXRoLmpvaW4oYXBwUm9vdCwgY2FjaGVEaXIgfHwgJy5jYWNoZScpO1xyXG5cclxuICBpZiAocHJvZHVjdGlvbk1vZGUgPT09IG51bGwpIHtcclxuICAgIHByb2R1Y3Rpb25Nb2RlID0gISFzdGF0U3luY05vRXhjZXB0aW9uKHJvb3RDYWNoZURpcik7XHJcbiAgfVxyXG5cclxuICBpZiAocHJvZHVjdGlvbk1vZGUpIHtcclxuICAgIGNvbXBpbGVySG9zdCA9IENvbXBpbGVySG9zdC5jcmVhdGVSZWFkb25seUZyb21Db25maWd1cmF0aW9uU3luYyhyb290Q2FjaGVEaXIsIGFwcFJvb3QpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBpZiBjYWNoZURpciB3YXMgcGFzc2VkIGluLCBwYXNzIGl0IGFsb25nLiBPdGhlcndpc2UsIGRlZmF1bHQgdG8gYSB0ZW1wZGlyLlxyXG4gICAgY29uc3QgY2FjaGVQYXRoID0gY2FjaGVEaXIgPyByb290Q2FjaGVEaXIgOiBudWxsO1xyXG4gICAgY29uc3QgbWFwUGF0aCA9IHNvdXJjZU1hcFBhdGggPyBwYXRoLmpvaW4oYXBwUm9vdCwgc291cmNlTWFwUGF0aCkgOiBjYWNoZVBhdGg7XHJcbiAgICBjb21waWxlckhvc3QgPSBjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3RTeW5jKGFwcFJvb3QsIGNhY2hlUGF0aCwgbWFwUGF0aCk7XHJcbiAgfVxyXG5cclxuICBpbml0aWFsaXplR2xvYmFsSG9va3MoY29tcGlsZXJIb3N0LCBwcm9kdWN0aW9uTW9kZSk7XHJcbiAgcmVxdWlyZS5tYWluLnJlcXVpcmUobWFpbk1vZHVsZSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHtAbGluayBDb21waWxlckhvc3R9IHdpdGggdGhlIGdpdmVuIGluZm9ybWF0aW9uLiBUaGlzIG1ldGhvZCBpc1xyXG4gKiB1c3VhbGx5IGNhbGxlZCBieSB7QGxpbmsgY3JlYXRlQ29tcGlsZXJIb3N0RnJvbVByb2plY3RSb290fS5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlndXJhdGlvbihpbmZvKSB7XHJcbiAgbGV0IGNvbXBpbGVycyA9IGNyZWF0ZUNvbXBpbGVycygpO1xyXG4gIGxldCByb290Q2FjaGVEaXIgPSBpbmZvLnJvb3RDYWNoZURpciB8fCBjYWxjdWxhdGVEZWZhdWx0Q29tcGlsZUNhY2hlRGlyZWN0b3J5KCk7XHJcbiAgY29uc3Qgc291cmNlTWFwUGF0aCA9IGluZm8uc291cmNlTWFwUGF0aCB8fCBpbmZvLnJvb3RDYWNoZURpcjtcclxuXHJcbiAgaWYgKGluZm8uc291cmNlTWFwUGF0aCkge1xyXG4gICAgY3JlYXRlU291cmNlTWFwRGlyZWN0b3J5KHNvdXJjZU1hcFBhdGgpO1xyXG4gIH1cclxuXHJcbiAgZChgQ3JlYXRpbmcgQ29tcGlsZXJIb3N0OiAke0pTT04uc3RyaW5naWZ5KGluZm8pfSwgcm9vdENhY2hlRGlyID0gJHtyb290Q2FjaGVEaXJ9LCBzb3VyY2VNYXBQYXRoID0gJHtzb3VyY2VNYXBQYXRofWApO1xyXG4gIGxldCBmaWxlQ2hhbmdlQ2FjaGUgPSBuZXcgRmlsZUNoYW5nZWRDYWNoZShpbmZvLmFwcFJvb3QpO1xyXG5cclxuICBsZXQgY29tcGlsZXJJbmZvID0gcGF0aC5qb2luKHJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xyXG4gIGxldCBqc29uID0ge307XHJcbiAgaWYgKGZzLmV4aXN0c1N5bmMoY29tcGlsZXJJbmZvKSkge1xyXG4gICAgbGV0IGJ1ZiA9IGZzLnJlYWRGaWxlU3luYyhjb21waWxlckluZm8pO1xyXG4gICAganNvbiA9IEpTT04ucGFyc2UoemxpYi5ndW56aXBTeW5jKGJ1ZikpO1xyXG4gICAgZmlsZUNoYW5nZUNhY2hlID0gRmlsZUNoYW5nZWRDYWNoZS5sb2FkRnJvbURhdGEoanNvbi5maWxlQ2hhbmdlQ2FjaGUsIGluZm8uYXBwUm9vdCwgZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgT2JqZWN0LmtleXMoaW5mby5vcHRpb25zIHx8IHt9KS5mb3JFYWNoKCh4KSA9PiB7XHJcbiAgICBsZXQgb3B0cyA9IGluZm8ub3B0aW9uc1t4XTtcclxuICAgIGlmICghKHggaW4gY29tcGlsZXJzKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvdW5kIGNvbXBpbGVyIHNldHRpbmdzIGZvciBtaXNzaW5nIGNvbXBpbGVyOiAke3h9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTkI6IExldCdzIGhvcGUgdGhpcyBpc24ndCBhIHZhbGlkIGNvbXBpbGVyIG9wdGlvbi4uLlxyXG4gICAgaWYgKG9wdHMucGFzc3Rocm91Z2gpIHtcclxuICAgICAgY29tcGlsZXJzW3hdID0gY29tcGlsZXJzWyd0ZXh0L3BsYWluJ107XHJcbiAgICAgIGRlbGV0ZSBvcHRzLnBhc3N0aHJvdWdoO1xyXG4gICAgfVxyXG5cclxuICAgIGQoYFNldHRpbmcgb3B0aW9ucyBmb3IgJHt4fTogJHtKU09OLnN0cmluZ2lmeShvcHRzKX1gKTtcclxuICAgIGNvbXBpbGVyc1t4XS5jb21waWxlck9wdGlvbnMgPSBvcHRzO1xyXG4gIH0pO1xyXG5cclxuICBsZXQgcmV0ID0gbmV3IENvbXBpbGVySG9zdChyb290Q2FjaGVEaXIsIGNvbXBpbGVycywgZmlsZUNoYW5nZUNhY2hlLCBmYWxzZSwgY29tcGlsZXJzWyd0ZXh0L3BsYWluJ10sIG51bGwsIGpzb24ubWltZVR5cGVzVG9SZWdpc3Rlcik7XHJcblxyXG4gIC8vIE5COiBJdCdzIHN1cGVyIGltcG9ydGFudCB0aGF0IHdlIGd1YXJhbnRlZSB0aGF0IHRoZSBjb25maWd1cmF0aW9uIGlzIHNhdmVkXHJcbiAgLy8gb3V0LCBiZWNhdXNlIHdlJ2xsIG5lZWQgdG8gcmUtcmVhZCBpdCBpbiB0aGUgcmVuZGVyZXIgcHJvY2Vzc1xyXG4gIGQoYENyZWF0ZWQgY29tcGlsZXIgaG9zdCB3aXRoIG9wdGlvbnM6ICR7SlNPTi5zdHJpbmdpZnkoaW5mbyl9YCk7XHJcbiAgcmV0LnNhdmVDb25maWd1cmF0aW9uU3luYygpO1xyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgY29tcGlsZXIgaG9zdCBmcm9tIGEgLmJhYmVscmMgZmlsZS4gVGhpcyBtZXRob2QgaXMgdXN1YWxseSBjYWxsZWRcclxuICogZnJvbSB7QGxpbmsgY3JlYXRlQ29tcGlsZXJIb3N0RnJvbVByb2plY3RSb290fSBpbnN0ZWFkIG9mIHVzZWQgZGlyZWN0bHkuXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZSAgVGhlIHBhdGggdG8gYSAuYmFiZWxyYyBmaWxlXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gcm9vdENhY2hlRGlyIChvcHRpb25hbCkgIFRoZSBkaXJlY3RvcnkgdG8gdXNlIGFzIGEgY2FjaGUuXHJcbiAqXHJcbiAqIEByZXR1cm4ge1Byb21pc2U8Q29tcGlsZXJIb3N0Pn0gIEEgc2V0LXVwIGNvbXBpbGVyIGhvc3RcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb21waWxlckhvc3RGcm9tQmFiZWxSYyhmaWxlLCByb290Q2FjaGVEaXI9bnVsbCwgc291cmNlTWFwUGF0aCA9IG51bGwpIHtcclxuICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoYXdhaXQgcGZzLnJlYWRGaWxlKGZpbGUsICd1dGY4JykpO1xyXG5cclxuICAvLyBwYWNrYWdlLmpzb25cclxuICBpZiAoJ2JhYmVsJyBpbiBpbmZvKSB7XHJcbiAgICBpbmZvID0gaW5mby5iYWJlbDtcclxuICB9XHJcblxyXG4gIGlmICgnZW52JyBpbiBpbmZvKSB7XHJcbiAgICBsZXQgb3VyRW52ID0gcHJvY2Vzcy5lbnYuQkFCRUxfRU5WIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WIHx8ICdkZXZlbG9wbWVudCc7XHJcbiAgICBpbmZvID0gaW5mby5lbnZbb3VyRW52XTtcclxuICB9XHJcblxyXG4gIC8vIEFyZSB3ZSBzdGlsbCBwYWNrYWdlLmpzb24gKGkuZS4gaXMgdGhlcmUgbm8gYmFiZWwgaW5mbyB3aGF0c29ldmVyPylcclxuICBpZiAoJ25hbWUnIGluIGluZm8gJiYgJ3ZlcnNpb24nIGluIGluZm8pIHtcclxuICAgIGxldCBhcHBSb290ID0gcGF0aC5kaXJuYW1lKGZpbGUpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWd1cmF0aW9uKHtcclxuICAgICAgYXBwUm9vdDogYXBwUm9vdCxcclxuICAgICAgb3B0aW9uczogZ2V0RGVmYXVsdENvbmZpZ3VyYXRpb24oYXBwUm9vdCksXHJcbiAgICAgIHJvb3RDYWNoZURpcixcclxuICAgICAgc291cmNlTWFwUGF0aFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ3VyYXRpb24oe1xyXG4gICAgYXBwUm9vdDogcGF0aC5kaXJuYW1lKGZpbGUpLFxyXG4gICAgb3B0aW9uczoge1xyXG4gICAgICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc6IGluZm9cclxuICAgIH0sXHJcbiAgICByb290Q2FjaGVEaXIsXHJcbiAgICBzb3VyY2VNYXBQYXRoXHJcbiAgfSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGNvbXBpbGVyIGhvc3QgZnJvbSBhIC5jb21waWxlcmMgZmlsZS4gVGhpcyBtZXRob2QgaXMgdXN1YWxseSBjYWxsZWRcclxuICogZnJvbSB7QGxpbmsgY3JlYXRlQ29tcGlsZXJIb3N0RnJvbVByb2plY3RSb290fSBpbnN0ZWFkIG9mIHVzZWQgZGlyZWN0bHkuXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZSAgVGhlIHBhdGggdG8gYSAuY29tcGlsZXJjIGZpbGVcclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfSByb290Q2FjaGVEaXIgKG9wdGlvbmFsKSAgVGhlIGRpcmVjdG9yeSB0byB1c2UgYXMgYSBjYWNoZS5cclxuICpcclxuICogQHJldHVybiB7UHJvbWlzZTxDb21waWxlckhvc3Q+fSAgQSBzZXQtdXAgY29tcGlsZXIgaG9zdFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWdGaWxlKGZpbGUsIHJvb3RDYWNoZURpcj1udWxsLCBzb3VyY2VNYXBQYXRoID0gbnVsbCkge1xyXG4gIGxldCBpbmZvID0gSlNPTi5wYXJzZShhd2FpdCBwZnMucmVhZEZpbGUoZmlsZSwgJ3V0ZjgnKSk7XHJcblxyXG4gIGlmICgnZW52JyBpbiBpbmZvKSB7XHJcbiAgICBsZXQgb3VyRW52ID0gcHJvY2Vzcy5lbnYuRUxFQ1RST05fQ09NUElMRV9FTlYgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgfHwgJ2RldmVsb3BtZW50JztcclxuICAgIGluZm8gPSBpbmZvLmVudltvdXJFbnZdO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWd1cmF0aW9uKHtcclxuICAgIGFwcFJvb3Q6IHBhdGguZGlybmFtZShmaWxlKSxcclxuICAgIG9wdGlvbnM6IGluZm8sXHJcbiAgICByb290Q2FjaGVEaXIsXHJcbiAgICBzb3VyY2VNYXBQYXRoXHJcbiAgfSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGNvbmZpZ3VyZWQge0BsaW5rIENvbXBpbGVySG9zdH0gaW5zdGFuY2UgZnJvbSB0aGUgcHJvamVjdCByb290XHJcbiAqIGRpcmVjdG9yeS4gVGhpcyBtZXRob2QgZmlyc3Qgc2VhcmNoZXMgZm9yIGEgLmNvbXBpbGVyYyAob3IgLmNvbXBpbGVyYy5qc29uKSwgdGhlbiBmYWxscyBiYWNrIHRvIHRoZVxyXG4gKiBkZWZhdWx0IGxvY2F0aW9ucyBmb3IgQmFiZWwgY29uZmlndXJhdGlvbiBpbmZvLiBJZiBuZWl0aGVyIGFyZSBmb3VuZCwgZGVmYXVsdHNcclxuICogdG8gc3RhbmRhcmQgc2V0dGluZ3NcclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfSByb290RGlyICBUaGUgcm9vdCBhcHBsaWNhdGlvbiBkaXJlY3RvcnkgKGkuZS4gdGhlIGRpcmVjdG9yeVxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgaGFzIHRoZSBhcHAncyBwYWNrYWdlLmpzb24pXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gcm9vdENhY2hlRGlyIChvcHRpb25hbCkgIFRoZSBkaXJlY3RvcnkgdG8gdXNlIGFzIGEgY2FjaGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VNYXBQYXRoIChvcHRpb25hbCkgVGhlIGRpcmVjdG9yeSB0byBzdG9yZSBzb3VyY2VtYXAgc2VwYXJhdGVseVxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBjb21waWxlciBvcHRpb24gZW5hYmxlZCB0byBlbWl0LlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtQcm9taXNlPENvbXBpbGVySG9zdD59ICBBIHNldC11cCBjb21waWxlciBob3N0XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbVByb2plY3RSb290KHJvb3REaXIsIHJvb3RDYWNoZURpciA9IG51bGwsIHNvdXJjZU1hcFBhdGggPSBudWxsKSB7XHJcbiAgbGV0IGNvbXBpbGVyYyA9IHBhdGguam9pbihyb290RGlyLCAnLmNvbXBpbGVyYycpO1xyXG4gIGlmIChzdGF0U3luY05vRXhjZXB0aW9uKGNvbXBpbGVyYykpIHtcclxuICAgIGQoYEZvdW5kIGEgLmNvbXBpbGVyYyBhdCAke2NvbXBpbGVyY30sIHVzaW5nIGl0YCk7XHJcbiAgICByZXR1cm4gYXdhaXQgY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ0ZpbGUoY29tcGlsZXJjLCByb290Q2FjaGVEaXIsIHNvdXJjZU1hcFBhdGgpO1xyXG4gIH1cclxuICBjb21waWxlcmMgKz0gJy5qc29uJztcclxuICBpZiAoc3RhdFN5bmNOb0V4Y2VwdGlvbihjb21waWxlcmMpKSB7XHJcbiAgICBkKGBGb3VuZCBhIC5jb21waWxlcmMgYXQgJHtjb21waWxlcmN9LCB1c2luZyBpdGApO1xyXG4gICAgcmV0dXJuIGF3YWl0IGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWdGaWxlKGNvbXBpbGVyYywgcm9vdENhY2hlRGlyLCBzb3VyY2VNYXBQYXRoKTtcclxuICB9XHJcblxyXG4gIGxldCBiYWJlbHJjID0gcGF0aC5qb2luKHJvb3REaXIsICcuYmFiZWxyYycpO1xyXG4gIGlmIChzdGF0U3luY05vRXhjZXB0aW9uKGJhYmVscmMpKSB7XHJcbiAgICBkKGBGb3VuZCBhIC5iYWJlbHJjIGF0ICR7YmFiZWxyY30sIHVzaW5nIGl0YCk7XHJcbiAgICByZXR1cm4gYXdhaXQgY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUJhYmVsUmMoYmFiZWxyYywgcm9vdENhY2hlRGlyLCBzb3VyY2VNYXBQYXRoKTtcclxuICB9XHJcblxyXG4gIGQoYFVzaW5nIHBhY2thZ2UuanNvbiBvciBkZWZhdWx0IHBhcmFtZXRlcnMgYXQgJHtyb290RGlyfWApO1xyXG4gIHJldHVybiBhd2FpdCBjcmVhdGVDb21waWxlckhvc3RGcm9tQmFiZWxSYyhwYXRoLmpvaW4ocm9vdERpciwgJ3BhY2thZ2UuanNvbicpLCByb290Q2FjaGVEaXIsIHNvdXJjZU1hcFBhdGgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUJhYmVsUmNTeW5jKGZpbGUsIHJvb3RDYWNoZURpcj1udWxsLCBzb3VyY2VNYXBQYXRoID0gbnVsbCkge1xyXG4gIGxldCBpbmZvID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0ZjgnKSk7XHJcblxyXG4gIC8vIHBhY2thZ2UuanNvblxyXG4gIGlmICgnYmFiZWwnIGluIGluZm8pIHtcclxuICAgIGluZm8gPSBpbmZvLmJhYmVsO1xyXG4gIH1cclxuXHJcbiAgaWYgKCdlbnYnIGluIGluZm8pIHtcclxuICAgIGxldCBvdXJFbnYgPSBwcm9jZXNzLmVudi5CQUJFTF9FTlYgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgfHwgJ2RldmVsb3BtZW50JztcclxuICAgIGluZm8gPSBpbmZvLmVudltvdXJFbnZdO1xyXG4gIH1cclxuXHJcbiAgLy8gQXJlIHdlIHN0aWxsIHBhY2thZ2UuanNvbiAoaS5lLiBpcyB0aGVyZSBubyBiYWJlbCBpbmZvIHdoYXRzb2V2ZXI/KVxyXG4gIGlmICgnbmFtZScgaW4gaW5mbyAmJiAndmVyc2lvbicgaW4gaW5mbykge1xyXG4gICAgbGV0IGFwcFJvb3QgPSBwYXRoLmRpcm5hbWUoZmlsZSlcclxuICAgIHJldHVybiBjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlndXJhdGlvbih7XHJcbiAgICAgIGFwcFJvb3Q6IGFwcFJvb3QsXHJcbiAgICAgIG9wdGlvbnM6IGdldERlZmF1bHRDb25maWd1cmF0aW9uKGFwcFJvb3QpLFxyXG4gICAgICByb290Q2FjaGVEaXIsXHJcbiAgICAgIHNvdXJjZU1hcFBhdGhcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWd1cmF0aW9uKHtcclxuICAgIGFwcFJvb3Q6IHBhdGguZGlybmFtZShmaWxlKSxcclxuICAgIG9wdGlvbnM6IHtcclxuICAgICAgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnOiBpbmZvXHJcbiAgICB9LFxyXG4gICAgcm9vdENhY2hlRGlyLFxyXG4gICAgc291cmNlTWFwUGF0aFxyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ0ZpbGVTeW5jKGZpbGUsIHJvb3RDYWNoZURpcj1udWxsLCBzb3VyY2VNYXBQYXRoID0gbnVsbCkge1xyXG4gIGxldCBpbmZvID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0ZjgnKSk7XHJcblxyXG4gIGlmICgnZW52JyBpbiBpbmZvKSB7XHJcbiAgICBsZXQgb3VyRW52ID0gcHJvY2Vzcy5lbnYuRUxFQ1RST05fQ09NUElMRV9FTlYgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgfHwgJ2RldmVsb3BtZW50JztcclxuICAgIGluZm8gPSBpbmZvLmVudltvdXJFbnZdO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWd1cmF0aW9uKHtcclxuICAgIGFwcFJvb3Q6IHBhdGguZGlybmFtZShmaWxlKSxcclxuICAgIG9wdGlvbnM6IGluZm8sXHJcbiAgICByb290Q2FjaGVEaXIsXHJcbiAgICBzb3VyY2VNYXBQYXRoXHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3RTeW5jKHJvb3REaXIsIHJvb3RDYWNoZURpciA9IG51bGwsIHNvdXJjZU1hcFBhdGggPSBudWxsKSB7XHJcbiAgbGV0IGNvbXBpbGVyYyA9IHBhdGguam9pbihyb290RGlyLCAnLmNvbXBpbGVyYycpO1xyXG4gIGlmIChzdGF0U3luY05vRXhjZXB0aW9uKGNvbXBpbGVyYykpIHtcclxuICAgIGQoYEZvdW5kIGEgLmNvbXBpbGVyYyBhdCAke2NvbXBpbGVyY30sIHVzaW5nIGl0YCk7XHJcbiAgICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ0ZpbGVTeW5jKGNvbXBpbGVyYywgcm9vdENhY2hlRGlyLCBzb3VyY2VNYXBQYXRoKTtcclxuICB9XHJcblxyXG4gIGxldCBiYWJlbHJjID0gcGF0aC5qb2luKHJvb3REaXIsICcuYmFiZWxyYycpO1xyXG4gIGlmIChzdGF0U3luY05vRXhjZXB0aW9uKGJhYmVscmMpKSB7XHJcbiAgICBkKGBGb3VuZCBhIC5iYWJlbHJjIGF0ICR7YmFiZWxyY30sIHVzaW5nIGl0YCk7XHJcbiAgICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUJhYmVsUmNTeW5jKGJhYmVscmMsIHJvb3RDYWNoZURpciwgc291cmNlTWFwUGF0aCk7XHJcbiAgfVxyXG5cclxuICBkKGBVc2luZyBwYWNrYWdlLmpzb24gb3IgZGVmYXVsdCBwYXJhbWV0ZXJzIGF0ICR7cm9vdERpcn1gKTtcclxuICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUJhYmVsUmNTeW5jKHBhdGguam9pbihyb290RGlyLCAncGFja2FnZS5qc29uJyksIHJvb3RDYWNoZURpciwgc291cmNlTWFwUGF0aCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoYXQgZWxlY3Ryb24tY29tcGlsZSB3b3VsZCB1c2UgYXMgYSBkZWZhdWx0IHJvb3RDYWNoZURpci4gVXN1YWxseSBvbmx5XHJcbiAqIHVzZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xyXG4gKlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICBBIHBhdGggdGhhdCBtYXkgb3IgbWF5IG5vdCBleGlzdCB3aGVyZSBlbGVjdHJvbi1jb21waWxlIHdvdWxkXHJcbiAqICAgICAgICAgICAgICAgICAgIHNldCB1cCBhIGRldmVsb3BtZW50IG1vZGUgY2FjaGUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRGVmYXVsdENvbXBpbGVDYWNoZURpcmVjdG9yeSgpIHtcclxuICBsZXQgdG1wRGlyID0gcHJvY2Vzcy5lbnYuVEVNUCB8fCBwcm9jZXNzLmVudi5UTVBESVIgfHwgJy90bXAnO1xyXG4gIGxldCBoYXNoID0gcmVxdWlyZSgnY3J5cHRvJykuY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKHByb2Nlc3MuZXhlY1BhdGgpLmRpZ2VzdCgnaGV4Jyk7XHJcblxyXG4gIGxldCBjYWNoZURpciA9IHBhdGguam9pbih0bXBEaXIsIGBjb21waWxlQ2FjaGVfJHtoYXNofWApO1xyXG4gIG1rZGlycC5zeW5jKGNhY2hlRGlyKTtcclxuXHJcbiAgZChgVXNpbmcgZGVmYXVsdCBjYWNoZSBkaXJlY3Rvcnk6ICR7Y2FjaGVEaXJ9YCk7XHJcbiAgcmV0dXJuIGNhY2hlRGlyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTb3VyY2VNYXBEaXJlY3Rvcnkoc291cmNlTWFwUGF0aCkge1xyXG4gIG1rZGlycC5zeW5jKHNvdXJjZU1hcFBhdGgpO1xyXG4gIGQoYFVzaW5nIHNlcGFyYXRlIHNvdXJjZW1hcCBwYXRoIGF0ICR7c291cmNlTWFwUGF0aH1gKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdmVyc2lvblRvRmxvYXQodmVyKSB7XHJcbiAgcmV0dXJuIHBhcnNlRmxvYXQodmVyLnJlcGxhY2UoL14oW15cXC5dXFwuW15cXC5dKVxcLi4qJC8sICckMScpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RWxlY3Ryb25WZXJzaW9uKHJvb3REaXIpIHtcclxuICBpZiAocHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbikge1xyXG4gICAgcmV0dXJuIHZlcnNpb25Ub0Zsb2F0KHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24pO1xyXG4gIH1cclxuXHJcbiAgbGV0IG91clBrZ0pzb24gPSByZXF1aXJlKHBhdGguam9pbihyb290RGlyLCAncGFja2FnZS5qc29uJykpO1xyXG5cclxuICBsZXQgdmVyc2lvbiA9IFsnZWxlY3Ryb24tcHJlYnVpbHQtY29tcGlsZScsICdlbGVjdHJvbiddLm1hcChtb2QgPT4ge1xyXG4gICAgaWYgKG91clBrZ0pzb24uZGV2RGVwZW5kZW5jaWVzICYmIG91clBrZ0pzb24uZGV2RGVwZW5kZW5jaWVzW21vZF0pIHtcclxuICAgICAgLy8gTkI6IGxvbCB0aGlzIGNvZGVcclxuICAgICAgbGV0IHZlclJhbmdlID0gb3VyUGtnSnNvbi5kZXZEZXBlbmRlbmNpZXNbbW9kXTtcclxuICAgICAgbGV0IG0gPSB2ZXJSYW5nZS5tYXRjaCgvKFxcZCtcXC5cXGQrXFwuXFxkKykvKTtcclxuICAgICAgaWYgKG0gJiYgbVsxXSkgcmV0dXJuIG1bMV07XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIHByb2Nlc3MubWFpbk1vZHVsZS5yZXF1aXJlKGAke21vZH0vcGFja2FnZS5qc29uYCkudmVyc2lvbjtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgLy8gTkI6IFRoaXMgdXN1YWxseSBkb2Vzbid0IHdvcmssIGJ1dCBzb21ldGltZXMgbWF5YmU/XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgbGV0IHAgPSBwYXRoLmpvaW4ocm9vdERpciwgbW9kLCAncGFja2FnZS5qc29uJyk7XHJcbiAgICAgIHJldHVybiByZXF1aXJlKHApLnZlcnNpb247XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH0pLmZpbmQoeCA9PiAhIXgpO1xyXG5cclxuICBpZiAoIXZlcnNpb24pIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF1dG9tYXRpY2FsbHkgZGlzY292ZXIgdGhlIHZlcnNpb24gb2YgRWxlY3Ryb24sIHlvdSBwcm9iYWJseSBuZWVkIGEgLmNvbXBpbGVyYyBmaWxlXCIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHZlcnNpb25Ub0Zsb2F0KHZlcnNpb24pO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGVmYXVsdCAuY29uZmlncmMgaWYgbm8gY29uZmlndXJhdGlvbiBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gIEEgbGlzdCBvZiBkZWZhdWx0IGNvbmZpZyBzZXR0aW5ncyBmb3IgZWxlY3Ryb24tY29tcGlsZXIuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdENvbmZpZ3VyYXRpb24ocm9vdERpcikge1xyXG4gIHJldHVybiB7XHJcbiAgICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc6IHtcclxuICAgICAgXCJwcmVzZXRzXCI6IFtcclxuICAgICAgICBbXCJlbnZcIiwge1xyXG4gICAgICAgICAgXCJ0YXJnZXRzXCI6IHtcclxuICAgICAgICAgICAgXCJlbGVjdHJvblwiOiBnZXRFbGVjdHJvblZlcnNpb24ocm9vdERpcilcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XSxcclxuICAgICAgICBcInJlYWN0XCJcclxuICAgICAgXSxcclxuICAgICAgXCJzb3VyY2VNYXBzXCI6IFwiaW5saW5lXCJcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQWxsb3dzIHlvdSB0byBjcmVhdGUgbmV3IGluc3RhbmNlcyBvZiBhbGwgY29tcGlsZXJzIHRoYXQgYXJlIHN1cHBvcnRlZCBieVxyXG4gKiBlbGVjdHJvbi1jb21waWxlIGFuZCB1c2UgdGhlbSBkaXJlY3RseS4gQ3VycmVudGx5IHN1cHBvcnRzIEJhYmVsLCBDb2ZmZWVTY3JpcHQsXHJcbiAqIFR5cGVTY3JpcHQsIExlc3MsIGFuZCBKYWRlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9ICBBbiBPYmplY3Qgd2hvc2UgS2V5cyBhcmUgTUlNRSB0eXBlcywgYW5kIHdob3NlIHZhbHVlc1xyXG4gKiBhcmUgaW5zdGFuY2VzIG9mIEB7bGluayBDb21waWxlckJhc2V9LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVycygpIHtcclxuICBpZiAoIWFsbENvbXBpbGVyQ2xhc3Nlcykge1xyXG4gICAgLy8gRmlyc3Qgd2Ugd2FudCB0byBzZWUgaWYgZWxlY3Ryb24tY29tcGlsZXJzIGl0c2VsZiBoYXMgYmVlbiBpbnN0YWxsZWQgd2l0aFxyXG4gICAgLy8gZGV2RGVwZW5kZW5jaWVzLiBJZiB0aGF0J3Mgbm90IHRoZSBjYXNlLCBjaGVjayB0byBzZWUgaWZcclxuICAgIC8vIGVsZWN0cm9uLWNvbXBpbGVycyBpcyBpbnN0YWxsZWQgYXMgYSBwZWVyIGRlcGVuZGVuY3kgKHByb2JhYmx5IGFzIGFcclxuICAgIC8vIGRldkRlcGVuZGVuY3kgb2YgdGhlIHJvb3QgcHJvamVjdCkuXHJcbiAgICBjb25zdCBsb2NhdGlvbnMgPSBbJ2VsZWN0cm9uLWNvbXBpbGVycycsICcuLi8uLi9lbGVjdHJvbi1jb21waWxlcnMnXTtcclxuXHJcbiAgICBmb3IgKGxldCBsb2NhdGlvbiBvZiBsb2NhdGlvbnMpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhbGxDb21waWxlckNsYXNzZXMgPSByZXF1aXJlKGxvY2F0aW9uKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIFlvbG9cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghYWxsQ29tcGlsZXJDbGFzc2VzKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVsZWN0cm9uIGNvbXBpbGVycyBub3QgZm91bmQgYnV0IHdlcmUgcmVxdWVzdGVkIHRvIGJlIGxvYWRlZFwiKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE5COiBOb3RlIHRoYXQgdGhpcyBjb2RlIGlzIGNhcmVmdWxseSBzZXQgdXAgc28gdGhhdCBJbmxpbmVIdG1sQ29tcGlsZXJcclxuICAvLyAoaS5lLiBjbGFzc2VzIHdpdGggYGNyZWF0ZUZyb21Db21waWxlcnNgKSBpbml0aWFsbHkgZ2V0IGFuIGVtcHR5IG9iamVjdCxcclxuICAvLyBidXQgd2lsbCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBmaW5hbCByZXN1bHQgb2Ygd2hhdCB3ZSByZXR1cm4sIHdoaWNoXHJcbiAgLy8gcmVzb2x2ZXMgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kgd2UnZCBvdGhlcndpc2UgaGF2ZSBoZXJlLlxyXG4gIGxldCByZXQgPSB7fTtcclxuICBsZXQgaW5zdGFudGlhdGVkQ2xhc3NlcyA9IGFsbENvbXBpbGVyQ2xhc3Nlcy5tYXAoKEtsYXNzKSA9PiB7XHJcbiAgICBpZiAoJ2NyZWF0ZUZyb21Db21waWxlcnMnIGluIEtsYXNzKSB7XHJcbiAgICAgIHJldHVybiBLbGFzcy5jcmVhdGVGcm9tQ29tcGlsZXJzKHJldCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbmV3IEtsYXNzKCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGluc3RhbnRpYXRlZENsYXNzZXMucmVkdWNlKChhY2MseCkgPT4ge1xyXG4gICAgbGV0IEtsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpLmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGZvciAobGV0IHR5cGUgb2YgS2xhc3MuZ2V0SW5wdXRNaW1lVHlwZXMoKSkgeyBhY2NbdHlwZV0gPSB4OyB9XHJcbiAgICByZXR1cm4gYWNjO1xyXG4gIH0sIHJldCk7XHJcblxyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuIl19